#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 32 1 8 1000000 321 322 320
    bytecblock 0x00 0x0000000000000000000000000000000000000000000000000000000000000000 0x0000000000000000 0x151f7c75 "d" "g" 0x640000000000000000 "p" 0x80 0x0f4240 0x28 "user withdrawal" 0xda7025b9 "admin withdrawal" 0x02 0x0000000000000001 0x0000000000000002 "scver" 0x4a968f8f
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:173
    // version = GlobalState<string>({ key: 'scver' })
    bytec 17 // "scver"
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:179
    // this.version.value = 'AVMSatoshiDice#1'
    pushbytes "AVMSatoshiDice#1"
    app_global_put

main_after_if_else@2:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:165
    // export class AvmSatoshiDice extends Contract {
    txn NumAppArgs
    bz main_bare_routing@21
    pushbytess 0x70a65e89 0xc61d56f5 0xa507e97a 0x9c7a08e8 0x3b199bf1 0xe36e57bf 0xc4bc7ee9 0x15f068e6 0x2df0082e 0x2812439d 0x269caf82 0x5cea6559 0xa72faf29 0xf0794cd6 // method "updateApplication(string)bool", method "sendOnlineKeyRegistration(byte[],byte[],byte[],uint64,uint64,uint64,uint64)byte[]", method "withdrawable(uint64,bool)uint512", method "withdraw(address,uint256,uint64,bool)uint512", method "CreateGameWithNativeToken(pay,uint64)(uint256,uint64,bool,bool,bool,uint64,uint64,uint64,uint256,uint64,uint256,uint64,uint256,uint64,address)", method "OptInToASA(pay,uint64)void", method "CreateGameWithASAToken(axfer,uint64)(uint256,uint64,bool,bool,bool,uint64,uint64,uint64,uint256,uint64,uint256,uint64,uint256,uint64,address)", method "CreateGameWithArc200Token(uint64,uint256,uint64)(uint256,uint64,bool,bool,bool,uint64,uint64,uint64,uint256,uint64,uint256,uint64,uint256,uint64,address)", method "StartGameWithNativeToken(pay,(uint64,address),uint64)(uint64,uint64,uint64,uint256,uint256,uint256,uint64,address,address,uint64)", method "StartGameWithASAToken(axfer,(uint64,address),uint64)(uint64,uint64,uint64,uint256,uint256,uint256,uint64,address,address,uint64)", method "StartGameWithArc200Token(uint256,uint64,(uint64,address),uint64)(uint64,uint64,uint64,uint256,uint256,uint256,uint64,address,address,uint64)", method "Game(address,uint64)(uint256,uint64,bool,bool,bool,uint64,uint64,uint64,uint256,uint64,uint256,uint64,uint256,uint64,address)", method "MyGame()(uint64,uint64,uint64,uint256,uint256,uint256,uint64,address,address,uint64)", method "ClaimGame()(uint64,uint64,uint64,uint256,uint256,uint256,uint64,address,address,uint64)"
    txna ApplicationArgs 0
    match main_updateApplication_route@5 main_sendOnlineKeyRegistration_route@6 main_withdrawable_route@7 main_withdraw_route@8 main_CreateGameWithNativeToken_route@9 main_OptInToASA_route@10 main_CreateGameWithASAToken_route@11 main_CreateGameWithArc200Token_route@12 main_StartGameWithNativeToken_route@13 main_StartGameWithASAToken_route@14 main_StartGameWithArc200Token_route@15 main_Game_route@16 main_MyGame_route@17 main_ClaimGame_route@18

main_after_if_else@25:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:165
    // export class AvmSatoshiDice extends Contract {
    intc_0 // 0
    return

main_ClaimGame_route@18:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:910
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub ClaimGame
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

main_MyGame_route@17:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:896
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub MyGame
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

main_Game_route@16:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:882
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:165
    // export class AvmSatoshiDice extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:882
    // @arc4.abimethod({ readonly: true })
    callsub Game
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

main_StartGameWithArc200Token_route@15:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:808
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:165
    // export class AvmSatoshiDice extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:808
    // @arc4.abimethod()
    callsub StartGameWithArc200Token
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

main_StartGameWithASAToken_route@14:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:742
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:165
    // export class AvmSatoshiDice extends Contract {
    txn GroupIndex
    intc_2 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:742
    // @arc4.abimethod()
    callsub StartGameWithASAToken
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

main_StartGameWithNativeToken_route@13:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:676
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:165
    // export class AvmSatoshiDice extends Contract {
    txn GroupIndex
    intc_2 // 1
    -
    dup
    gtxns TypeEnum
    intc_2 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:676
    // @arc4.abimethod()
    callsub StartGameWithNativeToken
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

main_CreateGameWithArc200Token_route@12:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:600
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:165
    // export class AvmSatoshiDice extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:600
    // @arc4.abimethod()
    callsub CreateGameWithArc200Token
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

main_CreateGameWithASAToken_route@11:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:536
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:165
    // export class AvmSatoshiDice extends Contract {
    txn GroupIndex
    intc_2 // 1
    -
    dup
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    txna ApplicationArgs 1
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:536
    // @arc4.abimethod()
    callsub CreateGameWithASAToken
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

main_OptInToASA_route@10:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:510
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:165
    // export class AvmSatoshiDice extends Contract {
    txn GroupIndex
    intc_2 // 1
    -
    dup
    gtxns TypeEnum
    intc_2 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:510
    // @arc4.abimethod()
    callsub OptInToASA
    intc_2 // 1
    return

main_CreateGameWithNativeToken_route@9:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:448
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:165
    // export class AvmSatoshiDice extends Contract {
    txn GroupIndex
    intc_2 // 1
    -
    dup
    gtxns TypeEnum
    intc_2 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:448
    // @arc4.abimethod()
    callsub CreateGameWithNativeToken
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

main_withdraw_route@8:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:291
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:165
    // export class AvmSatoshiDice extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:291
    // @arc4.abimethod()
    callsub withdraw
    dup
    len
    pushint 64 // 64
    <=
    assert // overflow
    pushint 64 // 64
    bzero
    b|
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

main_withdrawable_route@7:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:242
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:165
    // export class AvmSatoshiDice extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:242
    // @arc4.abimethod({ readonly: true })
    callsub withdrawable
    dup
    len
    pushint 64 // 64
    <=
    assert // overflow
    pushint 64 // 64
    bzero
    b|
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

main_sendOnlineKeyRegistration_route@6:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:212
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:165
    // export class AvmSatoshiDice extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    txna ApplicationArgs 3
    extract 2 0
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    txna ApplicationArgs 6
    btoi
    txna ApplicationArgs 7
    btoi
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:212
    // @arc4.abimethod()
    callsub sendOnlineKeyRegistration
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

main_updateApplication_route@5:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:203
    // @arc4.abimethod({ allowActions: 'UpdateApplication' })
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    assert // OnCompletion is not UpdateApplication
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:165
    // export class AvmSatoshiDice extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:203
    // @arc4.abimethod({ allowActions: 'UpdateApplication' })
    callsub updateApplication
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_3 // 0x151f7c75
    swap
    concat
    log
    intc_2 // 1
    return

main_bare_routing@21:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:165
    // export class AvmSatoshiDice extends Contract {
    txn OnCompletion
    bnz main_after_if_else@25
    txn ApplicationID
    !
    assert // can only call when creating
    intc_2 // 1
    return


// smart_contracts/avm_satoshi_dice/contract.algo.ts::AvmSatoshiDice._ConvertToUintN64UsingInterpretAsArc4(n: bytes) -> bytes:
_ConvertToUintN64UsingInterpretAsArc4:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:182
    // private _ConvertToUintN64UsingInterpretAsArc4(n: UintN256): UintN64 {
    proto 1 1
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:187
    // const part1 = arc4.interpretAsArc4<arc4.UintN64>(bytes.slice(0, 8), 'none')
    frame_dig -1
    substring 0 8
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:188
    // assert(part1.native === 0, 'Buffer overflow - part1')
    btoi
    !
    assert // Buffer overflow - part1
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:190
    // const part2 = arc4.interpretAsArc4<arc4.UintN64>(bytes.slice(8, 16), 'none')
    frame_dig -1
    substring 8 16
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:191
    // assert(part2.native === 0, 'Buffer overflow - part1')
    btoi
    !
    assert // Buffer overflow - part1
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:193
    // const part3 = arc4.interpretAsArc4<arc4.UintN64>(bytes.slice(16, 24), 'none')
    frame_dig -1
    substring 16 24
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:194
    // assert(part3.native === 0, 'Buffer overflow - part3')
    btoi
    !
    assert // Buffer overflow - part3
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:196
    // const uint64Bytes = bytes.slice(24, 32)
    frame_dig -1
    substring 24 32
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:197
    // return arc4.interpretAsArc4<arc4.UintN64>(uint64Bytes, 'none')
    retsub


// smart_contracts/avm_satoshi_dice/contract.algo.ts::AvmSatoshiDice.updateApplication(newVersion: bytes) -> uint64:
updateApplication:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:203-204
    // @arc4.abimethod({ allowActions: 'UpdateApplication' })
    // updateApplication(newVersion: string): boolean {
    proto 1 1
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:205
    // assert(Global.creatorAddress === Txn.sender, 'Only creator can update application')
    global CreatorAddress
    txn Sender
    ==
    assert // Only creator can update application
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:173
    // version = GlobalState<string>({ key: 'scver' })
    bytec 17 // "scver"
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:206
    // this.version.value = newVersion
    frame_dig -1
    app_global_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:207
    // return true
    intc_2 // 1
    retsub


// smart_contracts/avm_satoshi_dice/contract.algo.ts::AvmSatoshiDice.sendOnlineKeyRegistration(voteKey: bytes, selectionKey: bytes, stateProofKey: bytes, voteFirst: uint64, voteLast: uint64, voteKeyDilution: uint64, fee: uint64) -> bytes:
sendOnlineKeyRegistration:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:212-221
    // @arc4.abimethod()
    // public sendOnlineKeyRegistration(
    //   voteKey: bytes,
    //   selectionKey: bytes,
    //   stateProofKey: bytes,
    //   voteFirst: uint64,
    //   voteLast: uint64,
    //   voteKeyDilution: uint64,
    //   fee: uint64,
    // ): bytes {
    proto 7 1
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:222
    // assert(Global.creatorAddress === Txn.sender, 'Only creator can use this method')
    global CreatorAddress
    txn Sender
    ==
    assert // Only creator can use this method
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:223-233
    // const itxnResult = itxn
    //   .keyRegistration({
    //     selectionKey: selectionKey,
    //     stateProofKey: stateProofKey,
    //     voteFirst: voteFirst,
    //     voteKeyDilution: voteKeyDilution,
    //     voteLast: voteLast,
    //     voteKey: voteKey,
    //     fee: fee,
    //   })
    //   .submit()
    itxn_begin
    frame_dig -7
    itxn_field VotePK
    frame_dig -3
    itxn_field VoteLast
    frame_dig -2
    itxn_field VoteKeyDilution
    frame_dig -4
    itxn_field VoteFirst
    frame_dig -5
    itxn_field StateProofPK
    frame_dig -6
    itxn_field SelectionPK
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:223-232
    // const itxnResult = itxn
    //   .keyRegistration({
    //     selectionKey: selectionKey,
    //     stateProofKey: stateProofKey,
    //     voteFirst: voteFirst,
    //     voteKeyDilution: voteKeyDilution,
    //     voteLast: voteLast,
    //     voteKey: voteKey,
    //     fee: fee,
    //   })
    pushint 2 // 2
    itxn_field TypeEnum
    frame_dig -1
    itxn_field Fee
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:223-233
    // const itxnResult = itxn
    //   .keyRegistration({
    //     selectionKey: selectionKey,
    //     stateProofKey: stateProofKey,
    //     voteFirst: voteFirst,
    //     voteKeyDilution: voteKeyDilution,
    //     voteLast: voteLast,
    //     voteKey: voteKey,
    //     fee: fee,
    //   })
    //   .submit()
    itxn_submit
    itxn TxID
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:234
    // return itxnResult.txnId
    retsub


// smart_contracts/avm_satoshi_dice/contract.algo.ts::AvmSatoshiDice.withdrawable(assetId: bytes, isArc200Token: bytes) -> bytes:
withdrawable:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:242-243
    // @arc4.abimethod({ readonly: true })
    // public withdrawable(assetId: UintN64, isArc200Token: Bool): biguint {
    proto 2 1
    pushbytes ""
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:244-247
    // const key = new AddressAssetStruct({
    //   assetId: assetId,
    //   owner: new Address(Txn.sender),
    // })
    frame_dig -2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:246
    // owner: new Address(Txn.sender),
    txn Sender
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:244-247
    // const key = new AddressAssetStruct({
    //   assetId: assetId,
    //   owner: new Address(Txn.sender),
    // })
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:166
    // public games = BoxMap<AddressAssetStruct, GameStruct>({ keyPrefix: 'g' })
    bytec 5 // "g"
    swap
    concat
    dup
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:249
    // if (this.games(key).exists) {
    box_len
    bury 1
    bz withdrawable_else_body@2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:250
    // let toWithdrawIncludingFee: biguint = this.games(key).value.balance.native
    frame_dig 1
    box_get
    assert // Box must have value
    extract 0 32 // on error: Index access is out of bounds
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:251
    // const fee: biguint = toWithdrawIncludingFee / BigUint(40)
    dup
    bytec 10 // 0x28
    b/
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:252
    // const toWithdrawNet: biguint = toWithdrawIncludingFee - fee
    b-
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:253
    // return toWithdrawNet
    frame_bury 0
    retsub

withdrawable_else_body@2:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:255
    // if (Global.creatorAddress === Txn.sender) {
    global CreatorAddress
    txn Sender
    ==
    bz withdrawable_else_body@8
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:256
    // if (assetId.native === 0) {
    frame_dig -2
    btoi
    dup
    frame_bury 0
    bnz withdrawable_else_body@5
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:261
    // BigUint(Global.currentApplicationAddress.balance - Global.currentApplicationAddress.minBalance) -
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    -
    itob
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:168
    // public allDeposits = BoxMap<UintN64, UintN256>({ keyPrefix: 'd' })
    bytec 4 // "d"
    frame_dig -2
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:262
    // this.allDeposits(assetId).value.native
    box_get
    assert // Box must have value
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:261-262
    // BigUint(Global.currentApplicationAddress.balance - Global.currentApplicationAddress.minBalance) -
    // this.allDeposits(assetId).value.native
    b-
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:260-263
    // return (
    //   BigUint(Global.currentApplicationAddress.balance - Global.currentApplicationAddress.minBalance) -
    //   this.allDeposits(assetId).value.native
    // )
    frame_bury 0
    retsub

withdrawable_else_body@5:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:270
    // if (isArc200Token.native) {
    frame_dig -1
    intc_0 // 0
    getbit
    bz withdrawable_else_body@7
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:271
    // return 0n // todo
    pushbytes 0x
    frame_bury 0
    retsub

withdrawable_else_body@7:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:273
    // const balance = Asset(assetId.native).balance(Global.currentApplicationAddress)
    global CurrentApplicationAddress
    frame_dig 0
    asset_holding_get AssetBalance
    assert // account opted into asset
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:168
    // public allDeposits = BoxMap<UintN64, UintN256>({ keyPrefix: 'd' })
    bytec 4 // "d"
    frame_dig -2
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:274
    // const maxWithdrawableBalance: uint64 = balance - new UintN64(this.allDeposits(assetId).value.native).native
    box_get
    assert // Box must have value
    intc_0 // 0
    assert // overflow
    intc_3 // 8
    bzero
    b|
    btoi
    -
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:275
    // return BigUint(maxWithdrawableBalance)
    itob
    frame_bury 0
    retsub

withdrawable_else_body@8:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:279
    // return 0n
    pushbytes 0x
    frame_bury 0
    retsub


// smart_contracts/avm_satoshi_dice/contract.algo.ts::AvmSatoshiDice.withdraw(receiver: bytes, amount: bytes, assetId: bytes, isArc200Token: bytes) -> bytes:
withdraw:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:291-292
    // @arc4.abimethod()
    // public withdraw(receiver: Address, amount: UintN256, assetId: UintN64, isArc200Token: Bool): biguint {
    proto 4 1
    intc_0 // 0
    dupn 4
    pushbytes ""
    dupn 3
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:293-296
    // const key = new AddressAssetStruct({
    //   assetId: assetId,
    //   owner: new Address(Txn.sender),
    // })
    frame_dig -2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:295
    // owner: new Address(Txn.sender),
    txn Sender
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:293-296
    // const key = new AddressAssetStruct({
    //   assetId: assetId,
    //   owner: new Address(Txn.sender),
    // })
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:166
    // public games = BoxMap<AddressAssetStruct, GameStruct>({ keyPrefix: 'g' })
    bytec 5 // "g"
    swap
    concat
    dup
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:298
    // if (this.games(key).exists) {
    box_len
    bury 1
    bz withdraw_else_body@13
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:299
    // const game = this.games(key).value.copy()
    frame_dig 9
    box_get
    swap
    frame_bury 1
    assert // Box must have value
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:302
    // if (toWithdrawIncludingFee === BigUint(0)) {
    frame_dig -3
    pushbytes 0x
    b==
    frame_dig -3
    frame_bury 3
    bz withdraw_after_if_else@3
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:303
    // toWithdrawIncludingFee = game.balance.native
    frame_dig 1
    extract 0 32 // on error: Index access is out of bounds
    frame_bury 3

withdraw_after_if_else@3:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:305
    // const fee: biguint = toWithdrawIncludingFee / BigUint(40)
    frame_dig 3
    dup
    bytec 10 // 0x28
    b/
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:306
    // const toWithdrawNet: biguint = toWithdrawIncludingFee - fee
    dig 1
    swap
    b-
    frame_bury 4
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:309
    // game.balance.native >= toWithdrawIncludingFee,
    frame_dig 1
    dup
    cover 2
    extract 0 32 // on error: Index access is out of bounds
    dup
    dig 2
    b>=
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:308-311
    // assert(
    //   game.balance.native >= toWithdrawIncludingFee,
    //   'Game creator can withdraw from the game only the game deposit',
    // )
    assert // Game creator can withdraw from the game only the game deposit
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:168
    // public allDeposits = BoxMap<UintN64, UintN256>({ keyPrefix: 'd' })
    bytec 4 // "d"
    frame_dig -2
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:314
    // this.allDeposits(assetId).value.native >= toWithdrawIncludingFee,
    dup
    box_get
    assert // Box must have value
    dig 3
    b>=
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:313-316
    // assert(
    //   this.allDeposits(assetId).value.native >= toWithdrawIncludingFee,
    //   'allDeposits is smaller then withdrawal request',
    // )
    assert // allDeposits is smaller then withdrawal request
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:318
    // this.games(key).value.balance = new UintN256(game.balance.native - toWithdrawIncludingFee)
    swap
    dig 2
    b-
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    intc_1 // 32
    bzero
    dup
    frame_bury 0
    swap
    dig 1
    b|
    frame_dig 9
    dup
    cover 2
    box_get
    assert // Box must have value
    swap
    replace2 0
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:319
    // const prevAllDeposits: biguint = this.allDeposits(assetId).value.native
    dig 1
    box_get
    assert // Box must have value
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:320
    // const newAllDepositValue: biguint = prevAllDeposits - toWithdrawIncludingFee
    uncover 3
    b-
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:321
    // this.allDeposits(assetId).value = new UintN256(newAllDepositValue)
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    b|
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:323
    // if (game.isNativeToken.native) {
    intc 7 // 320
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    bz withdraw_after_if_else@6
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:324-331
    // itxn
    //   .payment({
    //     amount: new UintN64(toWithdrawNet).native,
    //     receiver: receiver.native,
    //     note: 'user withdrawal',
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:326
    // amount: new UintN64(toWithdrawNet).native,
    frame_dig 4
    dup
    len
    intc_3 // 8
    <=
    assert // overflow
    intc_3 // 8
    bzero
    dig 1
    b|
    btoi
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:328
    // note: 'user withdrawal',
    bytec 11 // "user withdrawal"
    itxn_field Note
    frame_dig -4
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:324-330
    // itxn
    //   .payment({
    //     amount: new UintN64(toWithdrawNet).native,
    //     receiver: receiver.native,
    //     note: 'user withdrawal',
    //     fee: 0,
    //   })
    intc_2 // 1
    itxn_field TypeEnum
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:329
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:324-331
    // itxn
    //   .payment({
    //     amount: new UintN64(toWithdrawNet).native,
    //     receiver: receiver.native,
    //     note: 'user withdrawal',
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:332
    // return toWithdrawNet
    frame_bury 0
    retsub

withdraw_after_if_else@6:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:334
    // if (game.isASAToken.native) {
    frame_dig 1
    intc 5 // 321
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    bz withdraw_after_if_else@9
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:335-343
    // itxn
    //   .assetTransfer({
    //     xferAsset: game.assetId.native,
    //     assetAmount: new UintN64(toWithdrawNet).native,
    //     assetReceiver: receiver.native,
    //     note: 'user withdrawal',
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:337
    // xferAsset: game.assetId.native,
    frame_dig 1
    intc_1 // 32
    extract_uint64
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:338
    // assetAmount: new UintN64(toWithdrawNet).native,
    frame_dig 4
    dup
    len
    intc_3 // 8
    <=
    assert // overflow
    intc_3 // 8
    bzero
    dig 1
    b|
    btoi
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:340
    // note: 'user withdrawal',
    bytec 11 // "user withdrawal"
    itxn_field Note
    frame_dig -4
    itxn_field AssetReceiver
    itxn_field AssetAmount
    swap
    itxn_field XferAsset
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:335-342
    // itxn
    //   .assetTransfer({
    //     xferAsset: game.assetId.native,
    //     assetAmount: new UintN64(toWithdrawNet).native,
    //     assetReceiver: receiver.native,
    //     note: 'user withdrawal',
    //     fee: 0,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:341
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:335-343
    // itxn
    //   .assetTransfer({
    //     xferAsset: game.assetId.native,
    //     assetAmount: new UintN64(toWithdrawNet).native,
    //     assetReceiver: receiver.native,
    //     note: 'user withdrawal',
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:344
    // return toWithdrawNet
    frame_bury 0
    retsub

withdraw_after_if_else@9:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:346
    // if (game.isArc200Token.native) {
    frame_dig 1
    intc 6 // 322
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    bz withdraw_after_if_else@12
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:348-355
    // itxn
    //   .applicationCall({
    //     appId: game.assetId.native,
    //     appArgs: [methodSelector('arc200_transfer(address,uint256)bool'), receiver, new UintN256(toWithdrawNet)],
    //     fee: 0,
    //     note: 'user withdrawal',
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:350
    // appId: game.assetId.native,
    frame_dig 1
    intc_1 // 32
    extract_uint64
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:351
    // appArgs: [methodSelector('arc200_transfer(address,uint256)bool'), receiver, new UintN256(toWithdrawNet)],
    frame_dig 4
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    dup
    frame_dig 0
    b|
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:353
    // note: 'user withdrawal',
    bytec 11 // "user withdrawal"
    itxn_field Note
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:351
    // appArgs: [methodSelector('arc200_transfer(address,uint256)bool'), receiver, new UintN256(toWithdrawNet)],
    bytec 12 // method "arc200_transfer(address,uint256)bool"
    itxn_field ApplicationArgs
    frame_dig -4
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationID
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:348-354
    // itxn
    //   .applicationCall({
    //     appId: game.assetId.native,
    //     appArgs: [methodSelector('arc200_transfer(address,uint256)bool'), receiver, new UintN256(toWithdrawNet)],
    //     fee: 0,
    //     note: 'user withdrawal',
    //   })
    pushint 6 // 6
    itxn_field TypeEnum
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:352
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:348-355
    // itxn
    //   .applicationCall({
    //     appId: game.assetId.native,
    //     appArgs: [methodSelector('arc200_transfer(address,uint256)bool'), receiver, new UintN256(toWithdrawNet)],
    //     fee: 0,
    //     note: 'user withdrawal',
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:356
    // return toWithdrawNet
    frame_bury 0
    retsub

withdraw_after_if_else@12:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:359
    // return BigUint(0)
    pushbytes 0x
    frame_bury 0
    retsub

withdraw_else_body@13:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:362
    // if (Global.creatorAddress === Txn.sender) {
    global CreatorAddress
    txn Sender
    ==
    assert // The game for this asset does not exists
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:365
    // if (assetId.native === 0) {
    frame_dig -2
    btoi
    dup
    frame_bury 6
    bnz withdraw_else_body@19
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:367
    // BigUint(Global.currentApplicationAddress.balance - Global.currentApplicationAddress.minBalance) >=
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    -
    itob
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:168
    // public allDeposits = BoxMap<UintN64, UintN256>({ keyPrefix: 'd' })
    bytec 4 // "d"
    frame_dig -2
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:368
    // this.allDeposits(assetId).value.native,
    dup
    box_get
    assert // Box must have value
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:367-368
    // BigUint(Global.currentApplicationAddress.balance - Global.currentApplicationAddress.minBalance) >=
    //   this.allDeposits(assetId).value.native,
    uncover 2
    b<=
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:366-370
    // assert(
    //   BigUint(Global.currentApplicationAddress.balance - Global.currentApplicationAddress.minBalance) >=
    //     this.allDeposits(assetId).value.native,
    //   'The curren balance plus min balance must be grater then all deposits to be able to withdraw',
    // )
    assert // The curren balance plus min balance must be grater then all deposits to be able to withdraw
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:373
    // BigUint(Global.currentApplicationAddress.balance - Global.currentApplicationAddress.minBalance) -
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    -
    itob
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:374
    // this.allDeposits(assetId).value.native
    swap
    box_get
    assert // Box must have value
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:373-374
    // BigUint(Global.currentApplicationAddress.balance - Global.currentApplicationAddress.minBalance) -
    // this.allDeposits(assetId).value.native
    b-
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:372-374
    // const maxWithdrawableBalance: biguint =
    //   BigUint(Global.currentApplicationAddress.balance - Global.currentApplicationAddress.minBalance) -
    //   this.allDeposits(assetId).value.native
    dup
    frame_bury 2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:376
    // assert(amount.native <= maxWithdrawableBalance, 'maxWithdrawableBalance is less then requested')
    frame_dig -3
    b>=
    assert // maxWithdrawableBalance is less then requested
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:377
    // let toWidraw: uint64 = this._ConvertToUintN64UsingInterpretAsArc4(amount).native
    frame_dig -3
    callsub _ConvertToUintN64UsingInterpretAsArc4
    btoi
    dup
    frame_bury 7
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:378
    // if (toWidraw === 0) {
    bnz withdraw_after_if_else@17
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:379
    // toWidraw = this._ConvertToUintN64UsingInterpretAsArc4(new UintN256(maxWithdrawableBalance)).native
    frame_dig 2
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    intc_1 // 32
    bzero
    b|
    callsub _ConvertToUintN64UsingInterpretAsArc4
    btoi
    frame_bury 7

withdraw_after_if_else@17:
    frame_dig 7
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:382-389
    // itxn
    //   .payment({
    //     amount: new UintN64(toWidraw).native,
    //     receiver: receiver.native,
    //     note: 'admin withdrawal',
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:384
    // amount: new UintN64(toWidraw).native,
    itob
    dup
    btoi
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:386
    // note: 'admin withdrawal',
    bytec 13 // "admin withdrawal"
    itxn_field Note
    frame_dig -4
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:382-388
    // itxn
    //   .payment({
    //     amount: new UintN64(toWidraw).native,
    //     receiver: receiver.native,
    //     note: 'admin withdrawal',
    //     fee: 0,
    //   })
    intc_2 // 1
    itxn_field TypeEnum
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:387
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:382-389
    // itxn
    //   .payment({
    //     amount: new UintN64(toWidraw).native,
    //     receiver: receiver.native,
    //     note: 'admin withdrawal',
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:390
    // return BigUint(toWidraw)
    frame_bury 0
    retsub

withdraw_else_body@19:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:391
    // } else if (isArc200Token.native) {
    frame_dig -1
    intc_0 // 0
    getbit
    bz withdraw_else_body@22
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:406-413
    // itxn
    //   .applicationCall({
    //     appId: assetId.native,
    //     appArgs: [methodSelector('arc200_transfer(address,uint256)bool'), receiver, amount],
    //     fee: 0,
    //     note: 'admin withdrawal',
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:411
    // note: 'admin withdrawal',
    bytec 13 // "admin withdrawal"
    itxn_field Note
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:409
    // appArgs: [methodSelector('arc200_transfer(address,uint256)bool'), receiver, amount],
    bytec 12 // method "arc200_transfer(address,uint256)bool"
    itxn_field ApplicationArgs
    frame_dig -4
    itxn_field ApplicationArgs
    frame_dig -3
    itxn_field ApplicationArgs
    frame_dig 6
    itxn_field ApplicationID
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:406-412
    // itxn
    //   .applicationCall({
    //     appId: assetId.native,
    //     appArgs: [methodSelector('arc200_transfer(address,uint256)bool'), receiver, amount],
    //     fee: 0,
    //     note: 'admin withdrawal',
    //   })
    pushint 6 // 6
    itxn_field TypeEnum
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:410
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:406-413
    // itxn
    //   .applicationCall({
    //     appId: assetId.native,
    //     appArgs: [methodSelector('arc200_transfer(address,uint256)bool'), receiver, amount],
    //     fee: 0,
    //     note: 'admin withdrawal',
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:414
    // return amount.native
    frame_dig -3
    frame_bury 0
    retsub

withdraw_else_body@22:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:417
    // const balance = Asset(assetId.native).balance(Global.currentApplicationAddress)
    global CurrentApplicationAddress
    frame_dig 6
    asset_holding_get AssetBalance
    assert // account opted into asset
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:168
    // public allDeposits = BoxMap<UintN64, UintN256>({ keyPrefix: 'd' })
    bytec 4 // "d"
    frame_dig -2
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:418
    // const maxWithdrawableBalance: uint64 = balance - new UintN64(this.allDeposits(assetId).value.native).native
    box_get
    assert // Box must have value
    intc_0 // 0
    assert // overflow
    intc_3 // 8
    bzero
    swap
    dig 1
    b|
    btoi
    uncover 2
    swap
    -
    dup
    frame_bury 5
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:419
    // assert(amount.native <= BigUint(maxWithdrawableBalance), 'maxWithdrawableBalance is less then requested')
    itob
    frame_dig -3
    b>=
    assert // maxWithdrawableBalance is less then requested
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:420
    // let toWidraw: uint64 = new UintN64(amount.native).native
    frame_dig -3
    b|
    btoi
    dup
    frame_bury 8
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:421
    // if (toWidraw === 0) {
    bnz withdraw_after_if_else@24
    frame_dig 5
    frame_bury 8

withdraw_after_if_else@24:
    frame_dig 8
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:425-433
    // itxn
    //   .assetTransfer({
    //     xferAsset: assetId.native,
    //     assetAmount: new UintN64(toWidraw).native,
    //     assetReceiver: receiver.native,
    //     note: 'admin withdrawal',
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:428
    // assetAmount: new UintN64(toWidraw).native,
    itob
    dup
    btoi
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:430
    // note: 'admin withdrawal',
    bytec 13 // "admin withdrawal"
    itxn_field Note
    frame_dig -4
    itxn_field AssetReceiver
    itxn_field AssetAmount
    frame_dig 6
    itxn_field XferAsset
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:425-432
    // itxn
    //   .assetTransfer({
    //     xferAsset: assetId.native,
    //     assetAmount: new UintN64(toWidraw).native,
    //     assetReceiver: receiver.native,
    //     note: 'admin withdrawal',
    //     fee: 0,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:431
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:425-433
    // itxn
    //   .assetTransfer({
    //     xferAsset: assetId.native,
    //     assetAmount: new UintN64(toWidraw).native,
    //     assetReceiver: receiver.native,
    //     note: 'admin withdrawal',
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:434
    // return BigUint(toWidraw)
    frame_bury 0
    retsub


// smart_contracts/avm_satoshi_dice/contract.algo.ts::AvmSatoshiDice.CreateGameWithNativeToken(txnDeposit: uint64, winRatio: bytes) -> bytes:
CreateGameWithNativeToken:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:448-449
    // @arc4.abimethod()
    // public CreateGameWithNativeToken(txnDeposit: gtxn.PaymentTxn, winRatio: UintN64): GameStruct {
    proto 2 1
    intc_0 // 0
    dupn 2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:450
    // const sender = new arc4.Address(txnDeposit.sender)
    frame_dig -2
    gtxns Sender
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:452
    // assert(winRatio.native <= 1_000_000, 'Win probability must be below 1 000 000')
    frame_dig -1
    btoi
    intc 4 // 1000000
    <=
    assert // Win probability must be below 1 000 000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:454
    // const fee: uint64 = txnDeposit.amount / 40 //2.5%
    frame_dig -2
    gtxns Amount
    dup
    pushint 40 // 40
    /
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:455
    // const deposit: uint64 = txnDeposit.amount - fee
    -
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:456
    // let prevDeposit: UintN256 = new UintN256(0)
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:168
    // public allDeposits = BoxMap<UintN64, UintN256>({ keyPrefix: 'd' })
    bytec 6 // 0x640000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:457
    // if (this.allDeposits(assetId).exists) {
    box_len
    bury 1
    bz CreateGameWithNativeToken_after_if_else@2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:168
    // public allDeposits = BoxMap<UintN64, UintN256>({ keyPrefix: 'd' })
    bytec 6 // 0x640000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:458
    // prevDeposit = this.allDeposits(assetId).value
    box_get
    swap
    frame_bury 5
    assert // Box must have value

CreateGameWithNativeToken_after_if_else@2:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:461
    // this.allDeposits(assetId).value = new UintN256(prevDeposit.native + BigUint(deposit))
    frame_dig 4
    itob
    dup
    frame_bury 1
    frame_dig 5
    b+
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    intc_1 // 32
    bzero
    dup
    frame_bury 0
    b|
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:168
    // public allDeposits = BoxMap<UintN64, UintN256>({ keyPrefix: 'd' })
    bytec 6 // 0x640000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:461
    // this.allDeposits(assetId).value = new UintN256(prevDeposit.native + BigUint(deposit))
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:463
    // assert(txnDeposit.receiver === Global.currentApplicationAddress, 'Receiver must be the gas station app')
    frame_dig -2
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Receiver must be the gas station app
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:451
    // const assetId = new UintN64(0)
    bytec_2 // 0x0000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:465-468
    // const key = new AddressAssetStruct({
    //   assetId: assetId,
    //   owner: sender,
    // })
    frame_dig 3
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:166
    // public games = BoxMap<AddressAssetStruct, GameStruct>({ keyPrefix: 'g' })
    bytec 5 // "g"
    swap
    concat
    dup
    frame_bury 2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:469
    // if (this.games(key).exists) {
    box_len
    bury 1
    bz CreateGameWithNativeToken_else_body@4
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:470
    // assert(this.games(key).value.isNativeToken === new Bool(true), 'The previous game was not for the native token')
    frame_dig 2
    dup
    box_get
    assert // Box must have value
    intc 7 // 320
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 8 // 0x80
    ==
    assert // The previous game was not for the native token
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:471
    // assert(this.games(key).value.isASAToken === new Bool(false), 'The previous game was ASA token')
    dup
    box_get
    assert // Box must have value
    intc 5 // 321
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_0 // 0x00
    ==
    assert // The previous game was ASA token
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:472
    // assert(this.games(key).value.assetId === assetId, 'The previous game was not for the native token')
    dup
    box_get
    assert // Box must have value
    extract 32 8 // on error: Index access is out of bounds
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:451
    // const assetId = new UintN64(0)
    bytec_2 // 0x0000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:472
    // assert(this.games(key).value.assetId === assetId, 'The previous game was not for the native token')
    ==
    assert // The previous game was not for the native token
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:475
    // const oldBalance = this.games(key).value.balance
    dup
    box_get
    assert // Box must have value
    extract 0 32 // on error: Index access is out of bounds
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:476
    // this.games(key).value.balance = new UintN256(oldBalance.native + BigUint(deposit))
    frame_dig 1
    b+
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    frame_dig 0
    b|
    dig 1
    box_get
    assert // Box must have value
    swap
    replace2 0
    dig 1
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:477
    // this.games(key).value.winRatio = winRatio
    dup
    box_get
    assert // Box must have value
    frame_dig -1
    replace2 177
    box_put

CreateGameWithNativeToken_after_if_else@5:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:502
    // return this.games(key).value
    frame_dig 2
    box_get
    assert // Box must have value
    frame_bury 0
    retsub

CreateGameWithNativeToken_else_body@4:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:481
    // balance: new UintN256(BigUint(deposit)),
    frame_dig 1
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    frame_dig 0
    b|
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:487
    // createdAtTime: new UintN64(Global.latestTimestamp),
    global LatestTimestamp
    itob
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:488
    // createdAtRound: new UintN64(Global.round),
    global Round
    itob
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:480-499
    // const newValue = new GameStruct({
    //   balance: new UintN256(BigUint(deposit)),
    //   assetId: assetId,
    //   isArc200Token: new Bool(false),
    //   isNativeToken: new Bool(true),
    //   isASAToken: new Bool(false),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    uncover 2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:451
    // const assetId = new UintN64(0)
    bytec_2 // 0x0000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:480-499
    // const newValue = new GameStruct({
    //   balance: new UintN256(BigUint(deposit)),
    //   assetId: assetId,
    //   isArc200Token: new Bool(false),
    //   isNativeToken: new Bool(true),
    //   isASAToken: new Bool(false),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:484
    // isNativeToken: new Bool(true),
    bytec 8 // 0x80
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:480-499
    // const newValue = new GameStruct({
    //   balance: new UintN256(BigUint(deposit)),
    //   assetId: assetId,
    //   isArc200Token: new Bool(false),
    //   isNativeToken: new Bool(true),
    //   isASAToken: new Bool(false),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    concat
    intc 5 // 321
    intc_0 // 0
    setbit
    intc 6 // 322
    intc_0 // 0
    setbit
    uncover 2
    concat
    swap
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:490
    // lastPlayTime: new UintN64(0),
    bytec_2 // 0x0000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:480-499
    // const newValue = new GameStruct({
    //   balance: new UintN256(BigUint(deposit)),
    //   assetId: assetId,
    //   isArc200Token: new Bool(false),
    //   isNativeToken: new Bool(true),
    //   isASAToken: new Bool(false),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:491
    // lastPlayAmount: new UintN256(0),
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:480-499
    // const newValue = new GameStruct({
    //   balance: new UintN256(BigUint(deposit)),
    //   assetId: assetId,
    //   isArc200Token: new Bool(false),
    //   isNativeToken: new Bool(true),
    //   isASAToken: new Bool(false),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:492
    // lastWinTime: new UintN64(0),
    bytec_2 // 0x0000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:480-499
    // const newValue = new GameStruct({
    //   balance: new UintN256(BigUint(deposit)),
    //   assetId: assetId,
    //   isArc200Token: new Bool(false),
    //   isNativeToken: new Bool(true),
    //   isASAToken: new Bool(false),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:493
    // lastWinAmount: new UintN256(0),
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:480-499
    // const newValue = new GameStruct({
    //   balance: new UintN256(BigUint(deposit)),
    //   assetId: assetId,
    //   isArc200Token: new Bool(false),
    //   isNativeToken: new Bool(true),
    //   isASAToken: new Bool(false),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:495
    // biggestWinTime: new UintN64(0),
    bytec_2 // 0x0000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:480-499
    // const newValue = new GameStruct({
    //   balance: new UintN256(BigUint(deposit)),
    //   assetId: assetId,
    //   isArc200Token: new Bool(false),
    //   isNativeToken: new Bool(true),
    //   isASAToken: new Bool(false),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:494
    // biggestWinAmount: new UintN256(0),
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:480-499
    // const newValue = new GameStruct({
    //   balance: new UintN256(BigUint(deposit)),
    //   assetId: assetId,
    //   isArc200Token: new Bool(false),
    //   isNativeToken: new Bool(true),
    //   isASAToken: new Bool(false),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    concat
    frame_dig -1
    concat
    frame_dig 3
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:500
    // this.games(key).value = newValue.copy()
    frame_dig 2
    swap
    box_put
    b CreateGameWithNativeToken_after_if_else@5


// smart_contracts/avm_satoshi_dice/contract.algo.ts::AvmSatoshiDice.OptInToASA(txnDeposit: uint64, assetId: bytes) -> void:
OptInToASA:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:510-511
    // @arc4.abimethod()
    // public OptInToASA(txnDeposit: gtxn.PaymentTxn, assetId: UintN64) {
    proto 2 0
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:513
    // txnDeposit.receiver === Global.currentApplicationAddress,
    frame_dig -2
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:512-515
    // assert(
    //   txnDeposit.receiver === Global.currentApplicationAddress,
    //   'Receiver of the optin fee must be the current smart contract',
    // )
    assert // Receiver of the optin fee must be the current smart contract
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:516
    // assert(txnDeposit.amount === 10_000_000, 'Opt in fee for new asset is 10 native tokens')
    frame_dig -2
    gtxns Amount
    pushint 10000000 // 10000000
    ==
    assert // Opt in fee for new asset is 10 native tokens
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:518
    // if (!Global.currentApplicationAddress.isOptedIn(Asset(assetId.native))) {
    global CurrentApplicationAddress
    frame_dig -1
    btoi
    dup
    cover 2
    asset_holding_get AssetBalance
    bury 1
    bnz OptInToASA_after_if_else@3
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:519-526
    // itxn
    //   .assetTransfer({
    //     xferAsset: assetId.native,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:523
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    itxn_field AssetReceiver
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:522
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    frame_dig 0
    itxn_field XferAsset
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:519-525
    // itxn
    //   .assetTransfer({
    //     xferAsset: assetId.native,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:524
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:519-526
    // itxn
    //   .assetTransfer({
    //     xferAsset: assetId.native,
    //     assetAmount: 0,
    //     assetReceiver: Global.currentApplicationAddress,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit

OptInToASA_after_if_else@3:
    retsub


// smart_contracts/avm_satoshi_dice/contract.algo.ts::AvmSatoshiDice.CreateGameWithASAToken(txnDeposit: uint64, winRatio: bytes) -> bytes:
CreateGameWithASAToken:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:536-537
    // @arc4.abimethod()
    // public CreateGameWithASAToken(txnDeposit: gtxn.AssetTransferTxn, winRatio: UintN64): GameStruct {
    proto 2 1
    intc_0 // 0
    dupn 2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:538
    // const sender = new arc4.Address(txnDeposit.sender)
    frame_dig -2
    gtxns Sender
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:539
    // assert(winRatio.native <= 1_000_000, 'Win probability must be below 1 000 000')
    frame_dig -1
    btoi
    intc 4 // 1000000
    <=
    assert // Win probability must be below 1 000 000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:540
    // const assetId = new UintN64(txnDeposit.xferAsset.id)
    frame_dig -2
    gtxns XferAsset
    itob
    dup
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:542
    // const fee: uint64 = txnDeposit.assetAmount / 40 //2.5%
    frame_dig -2
    gtxns AssetAmount
    dup
    pushint 40 // 40
    /
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:543
    // const deposit: uint64 = txnDeposit.assetAmount - fee
    -
    swap
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:544
    // let prevDeposit: UintN256 = new UintN256(0)
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    swap
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:168
    // public allDeposits = BoxMap<UintN64, UintN256>({ keyPrefix: 'd' })
    bytec 4 // "d"
    swap
    concat
    dup
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:545
    // if (this.allDeposits(assetId).exists) {
    box_len
    bury 1
    bz CreateGameWithASAToken_after_if_else@2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:546
    // prevDeposit = this.allDeposits(assetId).value
    frame_dig 7
    box_get
    swap
    frame_bury 6
    assert // Box must have value

CreateGameWithASAToken_after_if_else@2:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:549
    // this.allDeposits(assetId).value = new UintN256(prevDeposit.native + BigUint(deposit))
    frame_dig 5
    itob
    dup
    frame_bury 1
    frame_dig 6
    b+
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    intc_1 // 32
    bzero
    dup
    frame_bury 0
    b|
    frame_dig 7
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:551
    // assert(txnDeposit.assetReceiver === Global.currentApplicationAddress, 'Receiver must be the gas station app')
    frame_dig -2
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    assert // Receiver must be the gas station app
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:553-556
    // const key = new AddressAssetStruct({
    //   assetId: assetId,
    //   owner: sender,
    // })
    frame_dig 4
    frame_dig 3
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:166
    // public games = BoxMap<AddressAssetStruct, GameStruct>({ keyPrefix: 'g' })
    bytec 5 // "g"
    swap
    concat
    dup
    frame_bury 2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:557
    // if (this.games(key).exists) {
    box_len
    bury 1
    bz CreateGameWithASAToken_else_body@4
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:558
    // assert(this.games(key).value.isNativeToken === new Bool(false), 'The previous game was for the native token')
    frame_dig 2
    dup
    box_get
    assert // Box must have value
    intc 7 // 320
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_0 // 0x00
    ==
    assert // The previous game was for the native token
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:559
    // assert(this.games(key).value.isArc200Token === new Bool(false), 'The previous game was for the arc200 token')
    dup
    box_get
    assert // Box must have value
    intc 6 // 322
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_0 // 0x00
    ==
    assert // The previous game was for the arc200 token
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:560
    // assert(this.games(key).value.isASAToken === new Bool(true), 'The previous game was not for the ASA token')
    dup
    box_get
    assert // Box must have value
    intc 5 // 321
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 8 // 0x80
    ==
    assert // The previous game was not for the ASA token
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:561
    // assert(this.games(key).value.assetId === assetId, 'The previous game was not for the same token')
    dup
    box_get
    assert // Box must have value
    extract 32 8 // on error: Index access is out of bounds
    frame_dig 4
    ==
    assert // The previous game was not for the same token
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:564
    // const oldBalance = this.games(key).value.balance
    dup
    box_get
    assert // Box must have value
    extract 0 32 // on error: Index access is out of bounds
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:565
    // this.games(key).value.balance = new UintN256(oldBalance.native + BigUint(deposit))
    frame_dig 1
    b+
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    frame_dig 0
    b|
    dig 1
    box_get
    assert // Box must have value
    swap
    replace2 0
    dig 1
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:566
    // this.games(key).value.winRatio = winRatio
    dup
    box_get
    assert // Box must have value
    frame_dig -1
    replace2 177
    box_put

CreateGameWithASAToken_after_if_else@5:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:591
    // return this.games(key).value
    frame_dig 2
    box_get
    assert // Box must have value
    frame_bury 0
    retsub

CreateGameWithASAToken_else_body@4:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:570
    // balance: new UintN256(BigUint(deposit)),
    frame_dig 1
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    frame_dig 0
    b|
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:576
    // createdAtTime: new UintN64(Global.latestTimestamp),
    global LatestTimestamp
    itob
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:577
    // createdAtRound: new UintN64(Global.round),
    global Round
    itob
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:569-588
    // const newValue = new GameStruct({
    //   balance: new UintN256(BigUint(deposit)),
    //   assetId: assetId,
    //   isArc200Token: new Bool(false),
    //   isNativeToken: new Bool(false),
    //   isASAToken: new Bool(true),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    uncover 2
    frame_dig 4
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:573
    // isNativeToken: new Bool(false),
    bytec_0 // 0x00
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:569-588
    // const newValue = new GameStruct({
    //   balance: new UintN256(BigUint(deposit)),
    //   assetId: assetId,
    //   isArc200Token: new Bool(false),
    //   isNativeToken: new Bool(false),
    //   isASAToken: new Bool(true),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    concat
    intc 5 // 321
    intc_2 // 1
    setbit
    intc 6 // 322
    intc_0 // 0
    setbit
    uncover 2
    concat
    swap
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:579
    // lastPlayTime: new UintN64(0),
    bytec_2 // 0x0000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:569-588
    // const newValue = new GameStruct({
    //   balance: new UintN256(BigUint(deposit)),
    //   assetId: assetId,
    //   isArc200Token: new Bool(false),
    //   isNativeToken: new Bool(false),
    //   isASAToken: new Bool(true),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:580
    // lastPlayAmount: new UintN256(0),
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:569-588
    // const newValue = new GameStruct({
    //   balance: new UintN256(BigUint(deposit)),
    //   assetId: assetId,
    //   isArc200Token: new Bool(false),
    //   isNativeToken: new Bool(false),
    //   isASAToken: new Bool(true),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:581
    // lastWinTime: new UintN64(0),
    bytec_2 // 0x0000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:569-588
    // const newValue = new GameStruct({
    //   balance: new UintN256(BigUint(deposit)),
    //   assetId: assetId,
    //   isArc200Token: new Bool(false),
    //   isNativeToken: new Bool(false),
    //   isASAToken: new Bool(true),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:582
    // lastWinAmount: new UintN256(0),
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:569-588
    // const newValue = new GameStruct({
    //   balance: new UintN256(BigUint(deposit)),
    //   assetId: assetId,
    //   isArc200Token: new Bool(false),
    //   isNativeToken: new Bool(false),
    //   isASAToken: new Bool(true),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:584
    // biggestWinTime: new UintN64(0),
    bytec_2 // 0x0000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:569-588
    // const newValue = new GameStruct({
    //   balance: new UintN256(BigUint(deposit)),
    //   assetId: assetId,
    //   isArc200Token: new Bool(false),
    //   isNativeToken: new Bool(false),
    //   isASAToken: new Bool(true),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:583
    // biggestWinAmount: new UintN256(0),
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:569-588
    // const newValue = new GameStruct({
    //   balance: new UintN256(BigUint(deposit)),
    //   assetId: assetId,
    //   isArc200Token: new Bool(false),
    //   isNativeToken: new Bool(false),
    //   isASAToken: new Bool(true),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    concat
    frame_dig -1
    concat
    frame_dig 3
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:589
    // this.games(key).value = newValue.copy()
    frame_dig 2
    swap
    box_put
    b CreateGameWithASAToken_after_if_else@5


// smart_contracts/avm_satoshi_dice/contract.algo.ts::AvmSatoshiDice.CreateGameWithArc200Token(assetId: bytes, amount: bytes, winRatio: bytes) -> bytes:
CreateGameWithArc200Token:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:600-601
    // @arc4.abimethod()
    // public CreateGameWithArc200Token(assetId: UintN64, amount: UintN256, winRatio: UintN64): GameStruct {
    proto 3 1
    intc_0 // 0
    dup
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:602
    // const sender = new arc4.Address(Txn.sender)
    txn Sender
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:603
    // assert(winRatio.native <= 1_000_000, 'Win probability must be below 1 000 000')
    frame_dig -1
    btoi
    intc 4 // 1000000
    <=
    assert // Win probability must be below 1 000 000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:605
    // const fee: biguint = amount.native / BigUint(40) //2.5%
    frame_dig -2
    bytec 10 // 0x28
    b/
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:606
    // const deposit: biguint = amount.native - fee
    frame_dig -2
    swap
    b-
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:607
    // let prevDeposit: UintN256 = new UintN256(0)
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:168
    // public allDeposits = BoxMap<UintN64, UintN256>({ keyPrefix: 'd' })
    bytec 4 // "d"
    frame_dig -3
    concat
    dup
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:608
    // if (this.allDeposits(assetId).exists) {
    box_len
    bury 1
    bz CreateGameWithArc200Token_after_if_else@2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:609
    // prevDeposit = this.allDeposits(assetId).value
    frame_dig 5
    box_get
    swap
    frame_bury 4
    assert // Box must have value

CreateGameWithArc200Token_after_if_else@2:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:612
    // this.allDeposits(assetId).value = new UintN256(prevDeposit.native + BigUint(deposit))
    frame_dig 4
    frame_dig 3
    b+
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    intc_1 // 32
    bzero
    dup
    frame_bury 0
    b|
    frame_dig 5
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:615-625
    // itxn
    //   .applicationCall({
    //     appId: assetId.native,
    //     appArgs: [
    //       methodSelector('arc200_transferFrom(address,address,uint256)bool'),
    //       new Address(Txn.sender),
    //       new Address(Global.currentApplicationAddress),
    //       amount,
    //     ],
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:617
    // appId: assetId.native,
    frame_dig -3
    btoi
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:620
    // new Address(Txn.sender),
    txn Sender
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:621
    // new Address(Global.currentApplicationAddress),
    global CurrentApplicationAddress
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:619
    // methodSelector('arc200_transferFrom(address,address,uint256)bool'),
    bytec 18 // method "arc200_transferFrom(address,address,uint256)bool"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -2
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:615-624
    // itxn
    //   .applicationCall({
    //     appId: assetId.native,
    //     appArgs: [
    //       methodSelector('arc200_transferFrom(address,address,uint256)bool'),
    //       new Address(Txn.sender),
    //       new Address(Global.currentApplicationAddress),
    //       amount,
    //     ],
    //   })
    pushint 6 // 6
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:615-625
    // itxn
    //   .applicationCall({
    //     appId: assetId.native,
    //     appArgs: [
    //       methodSelector('arc200_transferFrom(address,address,uint256)bool'),
    //       new Address(Txn.sender),
    //       new Address(Global.currentApplicationAddress),
    //       amount,
    //     ],
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:627-630
    // const key = new AddressAssetStruct({
    //   assetId: assetId,
    //   owner: sender,
    // })
    frame_dig -3
    frame_dig 2
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:166
    // public games = BoxMap<AddressAssetStruct, GameStruct>({ keyPrefix: 'g' })
    bytec 5 // "g"
    swap
    concat
    dup
    frame_bury 1
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:631
    // if (this.games(key).exists) {
    box_len
    bury 1
    bz CreateGameWithArc200Token_else_body@5
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:632
    // assert(this.games(key).value.isNativeToken === new Bool(false), 'The previous game was for the native token')
    frame_dig 1
    dup
    box_get
    assert // Box must have value
    intc 7 // 320
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_0 // 0x00
    ==
    assert // The previous game was for the native token
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:633
    // assert(this.games(key).value.isArc200Token === new Bool(true), 'The previous game was NOT for the arc200 token')
    dup
    box_get
    assert // Box must have value
    intc 6 // 322
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 8 // 0x80
    ==
    assert // The previous game was NOT for the arc200 token
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:634
    // assert(this.games(key).value.isASAToken === new Bool(false), 'The previous game was for the ASA token')
    dup
    box_get
    assert // Box must have value
    intc 5 // 321
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_0 // 0x00
    ==
    assert // The previous game was for the ASA token
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:635
    // assert(this.games(key).value.assetId === assetId, 'The previous game was not for the same token')
    dup
    box_get
    assert // Box must have value
    extract 32 8 // on error: Index access is out of bounds
    frame_dig -3
    ==
    assert // The previous game was not for the same token
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:638
    // const oldBalance = this.games(key).value.balance
    dup
    box_get
    assert // Box must have value
    extract 0 32 // on error: Index access is out of bounds
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:639
    // this.games(key).value.balance = new UintN256(oldBalance.native + BigUint(deposit))
    frame_dig 3
    b+
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    frame_dig 0
    b|
    dig 1
    box_get
    assert // Box must have value
    swap
    replace2 0
    dig 1
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:640
    // this.games(key).value.winRatio = winRatio
    dup
    box_get
    assert // Box must have value
    frame_dig -1
    replace2 177
    box_put

CreateGameWithArc200Token_after_if_else@6:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:665
    // return this.games(key).value
    frame_dig 1
    box_get
    assert // Box must have value
    frame_bury 0
    retsub

CreateGameWithArc200Token_else_body@5:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:644
    // balance: new UintN256(deposit),
    frame_dig 3
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    frame_dig 0
    b|
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:650
    // createdAtTime: new UintN64(Global.latestTimestamp),
    global LatestTimestamp
    itob
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:651
    // createdAtRound: new UintN64(Global.round),
    global Round
    itob
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:643-662
    // const newValue = new GameStruct({
    //   balance: new UintN256(deposit),
    //   assetId: assetId,
    //   isArc200Token: new Bool(true),
    //   isNativeToken: new Bool(false),
    //   isASAToken: new Bool(false),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    uncover 2
    frame_dig -3
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:647
    // isNativeToken: new Bool(false),
    bytec_0 // 0x00
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:643-662
    // const newValue = new GameStruct({
    //   balance: new UintN256(deposit),
    //   assetId: assetId,
    //   isArc200Token: new Bool(true),
    //   isNativeToken: new Bool(false),
    //   isASAToken: new Bool(false),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    concat
    intc 5 // 321
    intc_0 // 0
    setbit
    intc 6 // 322
    intc_2 // 1
    setbit
    uncover 2
    concat
    swap
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:653
    // lastPlayTime: new UintN64(0),
    bytec_2 // 0x0000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:643-662
    // const newValue = new GameStruct({
    //   balance: new UintN256(deposit),
    //   assetId: assetId,
    //   isArc200Token: new Bool(true),
    //   isNativeToken: new Bool(false),
    //   isASAToken: new Bool(false),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:654
    // lastPlayAmount: new UintN256(0),
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:643-662
    // const newValue = new GameStruct({
    //   balance: new UintN256(deposit),
    //   assetId: assetId,
    //   isArc200Token: new Bool(true),
    //   isNativeToken: new Bool(false),
    //   isASAToken: new Bool(false),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:655
    // lastWinTime: new UintN64(0),
    bytec_2 // 0x0000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:643-662
    // const newValue = new GameStruct({
    //   balance: new UintN256(deposit),
    //   assetId: assetId,
    //   isArc200Token: new Bool(true),
    //   isNativeToken: new Bool(false),
    //   isASAToken: new Bool(false),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:656
    // lastWinAmount: new UintN256(0),
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:643-662
    // const newValue = new GameStruct({
    //   balance: new UintN256(deposit),
    //   assetId: assetId,
    //   isArc200Token: new Bool(true),
    //   isNativeToken: new Bool(false),
    //   isASAToken: new Bool(false),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:658
    // biggestWinTime: new UintN64(0),
    bytec_2 // 0x0000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:643-662
    // const newValue = new GameStruct({
    //   balance: new UintN256(deposit),
    //   assetId: assetId,
    //   isArc200Token: new Bool(true),
    //   isNativeToken: new Bool(false),
    //   isASAToken: new Bool(false),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:657
    // biggestWinAmount: new UintN256(0),
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:643-662
    // const newValue = new GameStruct({
    //   balance: new UintN256(deposit),
    //   assetId: assetId,
    //   isArc200Token: new Bool(true),
    //   isNativeToken: new Bool(false),
    //   isASAToken: new Bool(false),
    // 
    //   createdAtTime: new UintN64(Global.latestTimestamp),
    //   createdAtRound: new UintN64(Global.round),
    // 
    //   lastPlayTime: new UintN64(0),
    //   lastPlayAmount: new UintN256(0),
    //   lastWinTime: new UintN64(0),
    //   lastWinAmount: new UintN256(0),
    //   biggestWinAmount: new UintN256(0),
    //   biggestWinTime: new UintN64(0),
    // 
    //   winRatio: winRatio,
    //   owner: sender,
    // })
    concat
    frame_dig -1
    concat
    frame_dig 2
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:663
    // this.games(key).value = newValue.copy()
    frame_dig 1
    swap
    box_put
    b CreateGameWithArc200Token_after_if_else@6


// smart_contracts/avm_satoshi_dice/contract.algo.ts::AvmSatoshiDice.StartGameWithNativeToken(txnDeposit: uint64, game: bytes, winProbability: bytes) -> bytes:
StartGameWithNativeToken:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:676-681
    // @arc4.abimethod()
    // public StartGameWithNativeToken(
    //   txnDeposit: gtxn.PaymentTxn,
    //   game: AddressAssetStruct,
    //   winProbability: UintN64,
    // ): PlayStruct {
    proto 3 1
    intc_0 // 0
    dupn 4
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:682
    // const sender = new arc4.Address(txnDeposit.sender)
    frame_dig -3
    gtxns Sender
    dup
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:684
    // assert(Txn.sender === txnDeposit.sender, 'Sender of the app call must be the same as sender of the deposit')
    txn Sender
    dig 1
    ==
    assert // Sender of the app call must be the same as sender of the deposit
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:685
    // assert(game.assetId === assetId, 'Asset id in the tx does not match the game asset id')
    frame_dig -2
    extract 0 8 // on error: Index access is out of bounds
    dup
    cover 2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:683
    // const assetId = new UintN64(0)
    bytec_2 // 0x0000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:685
    // assert(game.assetId === assetId, 'Asset id in the tx does not match the game asset id')
    ==
    assert // Asset id in the tx does not match the game asset id
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:166
    // public games = BoxMap<AddressAssetStruct, GameStruct>({ keyPrefix: 'g' })
    bytec 5 // "g"
    frame_dig -2
    concat
    dup
    cover 2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:686
    // assert(this.games(game).exists, 'The game does not exist')
    dup
    box_len
    bury 1
    assert // The game does not exist
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:687
    // assert(this.games(game).value.assetId === assetId, 'This game must be played with native token')
    box_get
    assert // Box must have value
    extract 32 8 // on error: Index access is out of bounds
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:683
    // const assetId = new UintN64(0)
    bytec_2 // 0x0000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:687
    // assert(this.games(game).value.assetId === assetId, 'This game must be played with native token')
    ==
    assert // This game must be played with native token
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:688
    // assert(winProbability.native <= 1_000_000, 'Win probability must be below 1 000 000')
    frame_dig -1
    btoi
    dup
    cover 2
    intc 4 // 1000000
    <=
    assert // Win probability must be below 1 000 000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:167
    // public plays = BoxMap<Address, PlayStruct>({ keyPrefix: 'p' })
    bytec 7 // "p"
    swap
    concat
    dup
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:690
    // if (this.plays(sender).exists) {
    box_len
    bury 1
    bz StartGameWithNativeToken_after_if_else@3
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:692
    // assert(this.plays(sender).value.state.native > 1, 'Your previous game has not yet been claimed')
    frame_dig 9
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    intc_2 // 1
    >
    assert // Your previous game has not yet been claimed

StartGameWithNativeToken_after_if_else@3:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:697
    // this.games(game).value.lastPlayTime = new UintN64(Global.latestTimestamp)
    global LatestTimestamp
    itob
    frame_dig 7
    dup
    cover 2
    box_get
    assert // Box must have value
    swap
    replace2 57
    dig 1
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:698
    // this.games(game).value.lastPlayAmount = new UintN256(BigUint(txnDeposit.amount))
    frame_dig -3
    gtxns Amount
    dup
    itob
    dup
    frame_bury 3
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    intc_1 // 32
    bzero
    dup
    frame_bury 1
    b|
    dup
    frame_bury 0
    dig 2
    box_get
    assert // Box must have value
    swap
    replace2 65
    dig 2
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:703
    // const winAmount: biguint = BigUint((txnDeposit.amount * 1_000_000) / winProbability.native)
    intc 4 // 1000000
    *
    frame_dig 8
    /
    itob
    dup
    cover 2
    frame_bury 4
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:704
    // const maxPotWinAmount: biguint = this.games(game).value.balance.native / BigUint(2)
    box_get
    assert // Box must have value
    extract 0 32 // on error: Index access is out of bounds
    bytec 14 // 0x02
    b/
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:706
    // maxPotWinAmount >= winAmount,
    b<=
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:705-708
    // assert(
    //   maxPotWinAmount >= winAmount,
    //   'The game does not have enough balance for your win scenario. You can win max 50% of the game balance',
    // )
    assert // The game does not have enough balance for your win scenario. You can win max 50% of the game balance
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:710
    // let prevDeposit: UintN256 = new UintN256(0)
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    frame_bury 2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:168
    // public allDeposits = BoxMap<UintN64, UintN256>({ keyPrefix: 'd' })
    bytec 6 // 0x640000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:711
    // if (this.allDeposits(assetId).exists) {
    box_len
    bury 1
    bz StartGameWithNativeToken_after_if_else@5
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:168
    // public allDeposits = BoxMap<UintN64, UintN256>({ keyPrefix: 'd' })
    bytec 6 // 0x640000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:712
    // prevDeposit = this.allDeposits(assetId).value
    box_get
    swap
    frame_bury 2
    assert // Box must have value

StartGameWithNativeToken_after_if_else@5:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:714
    // this.allDeposits(assetId).value = new UintN256(prevDeposit.native + BigUint(txnDeposit.amount))
    frame_dig 2
    frame_dig 3
    b+
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    frame_dig 1
    dup
    cover 2
    b|
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:168
    // public allDeposits = BoxMap<UintN64, UintN256>({ keyPrefix: 'd' })
    bytec 6 // 0x640000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:714
    // this.allDeposits(assetId).value = new UintN256(prevDeposit.native + BigUint(txnDeposit.amount))
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:717
    // round: new UintN64(Global.round),
    global Round
    itob
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:721
    // expectedWin: new UintN256(winAmount),
    frame_dig 4
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    uncover 2
    b|
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:724
    // gameCreator: game.owner,
    frame_dig -2
    extract 8 32 // on error: Index access is out of bounds
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:726
    // update: new UintN64(Global.latestTimestamp),
    global LatestTimestamp
    itob
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:718
    // state: new UintN64(1),
    bytec 15 // 0x0000000000000001
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:716-727
    // const newValue = new PlayStruct({
    //   round: new UintN64(Global.round),
    //   state: new UintN64(1),
    //   winProbability: winProbability,
    //   deposit: new UintN256(BigUint(txnDeposit.amount)),
    //   expectedWin: new UintN256(winAmount),
    //   realTransfer: new UintN256(0n),
    //   owner: sender,
    //   gameCreator: game.owner,
    //   assetId: game.assetId,
    //   update: new UintN64(Global.latestTimestamp),
    // })
    frame_dig -1
    concat
    uncover 4
    concat
    frame_dig 0
    concat
    uncover 3
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:722
    // realTransfer: new UintN256(0n),
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:716-727
    // const newValue = new PlayStruct({
    //   round: new UintN64(Global.round),
    //   state: new UintN64(1),
    //   winProbability: winProbability,
    //   deposit: new UintN256(BigUint(txnDeposit.amount)),
    //   expectedWin: new UintN256(winAmount),
    //   realTransfer: new UintN256(0n),
    //   owner: sender,
    //   gameCreator: game.owner,
    //   assetId: game.assetId,
    //   update: new UintN64(Global.latestTimestamp),
    // })
    concat
    frame_dig 6
    concat
    uncover 2
    concat
    frame_dig 5
    concat
    swap
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:729
    // this.plays(sender).value = newValue.copy()
    frame_dig 9
    dig 1
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:730
    // return newValue
    frame_bury 0
    retsub


// smart_contracts/avm_satoshi_dice/contract.algo.ts::AvmSatoshiDice.StartGameWithASAToken(txnDeposit: uint64, game: bytes, winProbability: bytes) -> bytes:
StartGameWithASAToken:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:742-747
    // @arc4.abimethod()
    // public StartGameWithASAToken(
    //   txnDeposit: gtxn.AssetTransferTxn,
    //   game: AddressAssetStruct,
    //   winProbability: UintN64,
    // ): PlayStruct {
    proto 3 1
    intc_0 // 0
    dupn 5
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:748
    // const sender = new arc4.Address(txnDeposit.sender)
    frame_dig -3
    gtxns Sender
    dup
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:749
    // const assetId = new UintN64(txnDeposit.xferAsset.id)
    frame_dig -3
    gtxns XferAsset
    itob
    dup
    uncover 2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:750
    // assert(Txn.sender === txnDeposit.sender, 'Sender of the app call must be the same as sender of the deposit')
    txn Sender
    dig 1
    ==
    assert // Sender of the app call must be the same as sender of the deposit
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:751
    // assert(game.assetId.native === assetId.native, 'Asset id in the tx does not match the game asset id')
    frame_dig -2
    extract 0 8 // on error: Index access is out of bounds
    cover 2
    frame_dig -2
    intc_0 // 0
    extract_uint64
    dig 2
    btoi
    ==
    assert // Asset id in the tx does not match the game asset id
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:166
    // public games = BoxMap<AddressAssetStruct, GameStruct>({ keyPrefix: 'g' })
    bytec 5 // "g"
    frame_dig -2
    concat
    dup
    cover 3
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:752
    // assert(this.games(game).exists, 'The game does not exist')
    dup
    box_len
    bury 1
    assert // The game does not exist
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:753
    // assert(this.games(game).value.assetId === assetId, 'This game must be played with native token')
    box_get
    assert // Box must have value
    extract 32 8 // on error: Index access is out of bounds
    uncover 2
    ==
    assert // This game must be played with native token
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:754
    // assert(winProbability.native <= 1_000_000, 'Win probability must be below 1 000 000')
    frame_dig -1
    btoi
    dup
    cover 2
    intc 4 // 1000000
    <=
    assert // Win probability must be below 1 000 000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:167
    // public plays = BoxMap<Address, PlayStruct>({ keyPrefix: 'p' })
    bytec 7 // "p"
    swap
    concat
    dup
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:756
    // if (this.plays(sender).exists) {
    box_len
    bury 1
    bz StartGameWithASAToken_after_if_else@3
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:758
    // assert(this.plays(sender).value.state.native > 1, 'Your previous game has not yet been claimed')
    frame_dig 11
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    intc_2 // 1
    >
    assert // Your previous game has not yet been claimed

StartGameWithASAToken_after_if_else@3:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:763
    // this.games(game).value.lastPlayTime = new UintN64(Global.latestTimestamp)
    global LatestTimestamp
    itob
    frame_dig 9
    dup
    cover 2
    box_get
    assert // Box must have value
    swap
    replace2 57
    dig 1
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:764
    // this.games(game).value.lastPlayAmount = new UintN256(BigUint(txnDeposit.assetAmount))
    frame_dig -3
    gtxns AssetAmount
    dup
    itob
    dup
    frame_bury 3
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    intc_1 // 32
    bzero
    dup
    frame_bury 1
    b|
    dup
    frame_bury 0
    dig 2
    box_get
    assert // Box must have value
    swap
    replace2 65
    dig 2
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:769
    // const winAmount: biguint = BigUint((txnDeposit.assetAmount * 1_000_000) / winProbability.native)
    intc 4 // 1000000
    *
    frame_dig 10
    /
    itob
    dup
    cover 2
    frame_bury 5
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:770
    // const maxPotWinAmount: biguint = this.games(game).value.balance.native / BigUint(2)
    box_get
    assert // Box must have value
    extract 0 32 // on error: Index access is out of bounds
    bytec 14 // 0x02
    b/
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:772
    // maxPotWinAmount >= winAmount,
    b<=
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:771-774
    // assert(
    //   maxPotWinAmount >= winAmount,
    //   'The game does not have enough balance for your win scenario. You can win max 50% of the game balance',
    // )
    assert // The game does not have enough balance for your win scenario. You can win max 50% of the game balance
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:776
    // let prevDeposit: UintN256 = new UintN256(0)
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    frame_bury 2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:168
    // public allDeposits = BoxMap<UintN64, UintN256>({ keyPrefix: 'd' })
    bytec 4 // "d"
    frame_dig 7
    concat
    dup
    frame_bury 4
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:777
    // if (this.allDeposits(assetId).exists) {
    box_len
    bury 1
    bz StartGameWithASAToken_after_if_else@5
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:778
    // prevDeposit = this.allDeposits(assetId).value
    frame_dig 4
    box_get
    swap
    frame_bury 2
    assert // Box must have value

StartGameWithASAToken_after_if_else@5:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:780
    // this.allDeposits(assetId).value = new UintN256(prevDeposit.native + BigUint(txnDeposit.assetAmount))
    frame_dig 2
    frame_dig 3
    b+
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    frame_dig 1
    dup
    cover 2
    b|
    frame_dig 4
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:783
    // round: new UintN64(Global.round),
    global Round
    itob
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:787
    // expectedWin: new UintN256(winAmount),
    frame_dig 5
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    uncover 2
    b|
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:790
    // gameCreator: game.owner,
    frame_dig -2
    extract 8 32 // on error: Index access is out of bounds
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:792
    // update: new UintN64(Global.latestTimestamp),
    global LatestTimestamp
    itob
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:784
    // state: new UintN64(1),
    bytec 15 // 0x0000000000000001
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:782-793
    // const newValue = new PlayStruct({
    //   round: new UintN64(Global.round),
    //   state: new UintN64(1),
    //   winProbability: winProbability,
    //   deposit: new UintN256(BigUint(txnDeposit.assetAmount)),
    //   expectedWin: new UintN256(winAmount),
    //   realTransfer: new UintN256(0n),
    //   owner: sender,
    //   gameCreator: game.owner,
    //   assetId: game.assetId,
    //   update: new UintN64(Global.latestTimestamp),
    // })
    frame_dig -1
    concat
    uncover 4
    concat
    frame_dig 0
    concat
    uncover 3
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:788
    // realTransfer: new UintN256(0n),
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:782-793
    // const newValue = new PlayStruct({
    //   round: new UintN64(Global.round),
    //   state: new UintN64(1),
    //   winProbability: winProbability,
    //   deposit: new UintN256(BigUint(txnDeposit.assetAmount)),
    //   expectedWin: new UintN256(winAmount),
    //   realTransfer: new UintN256(0n),
    //   owner: sender,
    //   gameCreator: game.owner,
    //   assetId: game.assetId,
    //   update: new UintN64(Global.latestTimestamp),
    // })
    concat
    frame_dig 8
    concat
    uncover 2
    concat
    frame_dig 6
    concat
    swap
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:795
    // this.plays(sender).value = newValue.copy()
    frame_dig 11
    dig 1
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:796
    // return newValue
    frame_bury 0
    retsub


// smart_contracts/avm_satoshi_dice/contract.algo.ts::AvmSatoshiDice.StartGameWithArc200Token(amount: bytes, assetId: bytes, game: bytes, winProbability: bytes) -> bytes:
StartGameWithArc200Token:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:808-814
    // @arc4.abimethod()
    // public StartGameWithArc200Token(
    //   amount: UintN256,
    //   assetId: UintN64,
    //   game: AddressAssetStruct,
    //   winProbability: UintN64,
    // ): PlayStruct {
    proto 4 1
    intc_0 // 0
    dupn 2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:815
    // const sender = new arc4.Address(Txn.sender)
    txn Sender
    dup
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:816
    // assert(game.assetId === assetId, 'Asset id in the tx does not match the game asset id')
    frame_dig -2
    extract 0 8 // on error: Index access is out of bounds
    dup
    cover 2
    frame_dig -3
    ==
    assert // Asset id in the tx does not match the game asset id
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:166
    // public games = BoxMap<AddressAssetStruct, GameStruct>({ keyPrefix: 'g' })
    bytec 5 // "g"
    frame_dig -2
    concat
    dup
    cover 2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:817
    // assert(this.games(game).exists, 'The game does not exist')
    dup
    box_len
    bury 1
    assert // The game does not exist
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:818
    // assert(this.games(game).value.assetId === assetId, 'This game must be played with native token')
    box_get
    assert // Box must have value
    extract 32 8 // on error: Index access is out of bounds
    frame_dig -3
    ==
    assert // This game must be played with native token
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:819
    // assert(winProbability.native <= 1_000_000, 'Win probability must be below 1 000 000')
    frame_dig -1
    btoi
    dup
    cover 2
    intc 4 // 1000000
    <=
    assert // Win probability must be below 1 000 000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:167
    // public plays = BoxMap<Address, PlayStruct>({ keyPrefix: 'p' })
    bytec 7 // "p"
    swap
    concat
    dup
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:821
    // if (this.plays(sender).exists) {
    box_len
    bury 1
    bz StartGameWithArc200Token_after_if_else@3
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:823
    // assert(this.plays(sender).value.state.native > 1, 'Your previous game has not yet been claimed')
    frame_dig 7
    box_get
    assert // Box must have value
    intc_0 // 0
    extract_uint64
    intc_2 // 1
    >
    assert // Your previous game has not yet been claimed

StartGameWithArc200Token_after_if_else@3:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:829
    // this.games(game).value.lastPlayTime = new UintN64(Global.latestTimestamp)
    global LatestTimestamp
    itob
    frame_dig 5
    dup
    cover 2
    box_get
    assert // Box must have value
    swap
    replace2 57
    dig 1
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:830
    // this.games(game).value.lastPlayAmount = amount
    dup
    box_get
    assert // Box must have value
    frame_dig -4
    replace2 65
    dig 1
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:835-845
    // itxn
    //   .applicationCall({
    //     appId: game.assetId.native,
    //     appArgs: [
    //       methodSelector('arc200_transferFrom(address,address,uint256)bool'),
    //       new Address(Txn.sender),
    //       new Address(Global.currentApplicationAddress),
    //       amount,
    //     ],
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:837
    // appId: game.assetId.native,
    frame_dig -2
    intc_0 // 0
    extract_uint64
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:840
    // new Address(Txn.sender),
    txn Sender
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:841
    // new Address(Global.currentApplicationAddress),
    global CurrentApplicationAddress
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:839
    // methodSelector('arc200_transferFrom(address,address,uint256)bool'),
    bytec 18 // method "arc200_transferFrom(address,address,uint256)bool"
    itxn_field ApplicationArgs
    swap
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig -4
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:835-844
    // itxn
    //   .applicationCall({
    //     appId: game.assetId.native,
    //     appArgs: [
    //       methodSelector('arc200_transferFrom(address,address,uint256)bool'),
    //       new Address(Txn.sender),
    //       new Address(Global.currentApplicationAddress),
    //       amount,
    //     ],
    //   })
    pushint 6 // 6
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:835-845
    // itxn
    //   .applicationCall({
    //     appId: game.assetId.native,
    //     appArgs: [
    //       methodSelector('arc200_transferFrom(address,address,uint256)bool'),
    //       new Address(Txn.sender),
    //       new Address(Global.currentApplicationAddress),
    //       amount,
    //     ],
    //   })
    //   .submit()
    itxn_submit
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:847
    // const winAmount: biguint = (amount.native * BigUint(1_000_000)) / BigUint(winProbability.native)
    frame_dig -4
    bytec 9 // 0x0f4240
    b*
    frame_dig 6
    itob
    b/
    dup
    frame_bury 2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:848
    // const maxPotWinAmount: biguint = this.games(game).value.balance.native / BigUint(2)
    swap
    box_get
    assert // Box must have value
    extract 0 32 // on error: Index access is out of bounds
    bytec 14 // 0x02
    b/
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:850
    // maxPotWinAmount >= winAmount,
    b<=
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:849-852
    // assert(
    //   maxPotWinAmount >= winAmount,
    //   'The game does not have enough balance for your win scenario. You can win max 50% of the game balance',
    // )
    assert // The game does not have enough balance for your win scenario. You can win max 50% of the game balance
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:854
    // let prevDeposit: UintN256 = new UintN256(0)
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    frame_bury 0
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:168
    // public allDeposits = BoxMap<UintN64, UintN256>({ keyPrefix: 'd' })
    bytec 4 // "d"
    frame_dig -3
    concat
    dup
    frame_bury 1
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:855
    // if (this.allDeposits(assetId).exists) {
    box_len
    bury 1
    bz StartGameWithArc200Token_after_if_else@6
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:856
    // prevDeposit = this.allDeposits(assetId).value
    frame_dig 1
    box_get
    swap
    frame_bury 0
    assert // Box must have value

StartGameWithArc200Token_after_if_else@6:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:858
    // this.allDeposits(assetId).value = new UintN256(prevDeposit.native + amount.native)
    frame_dig 0
    frame_dig -4
    b+
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    intc_1 // 32
    bzero
    swap
    dig 1
    b|
    frame_dig 1
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:861
    // round: new UintN64(Global.round),
    global Round
    itob
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:864
    // deposit: new UintN256(amount.native),
    frame_dig -4
    dig 2
    b|
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:865
    // expectedWin: new UintN256(winAmount),
    frame_dig 2
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    uncover 3
    b|
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:868
    // gameCreator: game.owner,
    frame_dig -2
    extract 8 32 // on error: Index access is out of bounds
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:870
    // update: new UintN64(Global.latestTimestamp),
    global LatestTimestamp
    itob
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:862
    // state: new UintN64(1),
    bytec 15 // 0x0000000000000001
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:860-871
    // const newValue = new PlayStruct({
    //   round: new UintN64(Global.round),
    //   state: new UintN64(1),
    //   winProbability: winProbability,
    //   deposit: new UintN256(amount.native),
    //   expectedWin: new UintN256(winAmount),
    //   realTransfer: new UintN256(0n),
    //   owner: sender,
    //   gameCreator: game.owner,
    //   assetId: game.assetId,
    //   update: new UintN64(Global.latestTimestamp),
    // })
    frame_dig -1
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:866
    // realTransfer: new UintN256(0n),
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:860-871
    // const newValue = new PlayStruct({
    //   round: new UintN64(Global.round),
    //   state: new UintN64(1),
    //   winProbability: winProbability,
    //   deposit: new UintN256(amount.native),
    //   expectedWin: new UintN256(winAmount),
    //   realTransfer: new UintN256(0n),
    //   owner: sender,
    //   gameCreator: game.owner,
    //   assetId: game.assetId,
    //   update: new UintN64(Global.latestTimestamp),
    // })
    concat
    frame_dig 4
    concat
    uncover 2
    concat
    frame_dig 3
    concat
    swap
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:873
    // this.plays(sender).value = newValue.copy()
    frame_dig 7
    dig 1
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:874
    // return newValue
    frame_bury 0
    retsub


// smart_contracts/avm_satoshi_dice/contract.algo.ts::AvmSatoshiDice.Game(creator: bytes, assetId: bytes) -> bytes:
Game:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:882-883
    // @arc4.abimethod({ readonly: true })
    // public Game(creator: Address, assetId: UintN64): GameStruct {
    proto 2 1
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:884-887
    // const key = new AddressAssetStruct({
    //   assetId: assetId,
    //   owner: creator,
    // })
    frame_dig -1
    frame_dig -2
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:166
    // public games = BoxMap<AddressAssetStruct, GameStruct>({ keyPrefix: 'g' })
    bytec 5 // "g"
    swap
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:888
    // assert(this.games(key).exists, 'Did not found the game')
    dup
    box_len
    bury 1
    assert // Did not found the game
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:889
    // return this.games(key).value
    box_get
    assert // Box must have value
    retsub


// smart_contracts/avm_satoshi_dice/contract.algo.ts::AvmSatoshiDice.MyGame() -> bytes:
MyGame:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:167
    // public plays = BoxMap<Address, PlayStruct>({ keyPrefix: 'p' })
    bytec 7 // "p"
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:898
    // const sender = new arc4.Address(Txn.sender)
    txn Sender
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:167
    // public plays = BoxMap<Address, PlayStruct>({ keyPrefix: 'p' })
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:899
    // assert(this.plays(sender).exists, 'Did not found the game you are playing')
    dup
    box_len
    bury 1
    assert // Did not found the game you are playing
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:900
    // return this.plays(sender).value
    box_get
    assert // Box must have value
    retsub


// smart_contracts/avm_satoshi_dice/contract.algo.ts::AvmSatoshiDice.ClaimGame() -> bytes:
ClaimGame:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:910-911
    // @arc4.abimethod()
    // public ClaimGame(): PlayStruct {
    proto 0 1
    intc_0 // 0
    dupn 11
    pushbytes ""
    dup
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:912
    // const sender = new arc4.Address(Txn.sender)
    txn Sender
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:167
    // public plays = BoxMap<Address, PlayStruct>({ keyPrefix: 'p' })
    bytec 7 // "p"
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:912
    // const sender = new arc4.Address(Txn.sender)
    txn Sender
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:167
    // public plays = BoxMap<Address, PlayStruct>({ keyPrefix: 'p' })
    concat
    dupn 2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:913
    // assert(this.plays(sender).exists, 'Did not found the game you are playing')
    box_len
    bury 1
    assert // Did not found the game you are playing
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:914
    // const play = this.plays(sender).value.copy()
    dup
    box_get
    swap
    dup
    cover 2
    cover 3
    assert // Box must have value
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:917
    // assetId: play.assetId,
    dup
    extract 120 8 // on error: Index access is out of bounds
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:918
    // owner: play.gameCreator,
    dig 1
    extract 128 32 // on error: Index access is out of bounds
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:916-919
    // const key = new AddressAssetStruct({
    //   assetId: play.assetId,
    //   owner: play.gameCreator,
    // })
    concat
    dup
    cover 3
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:166
    // public games = BoxMap<AddressAssetStruct, GameStruct>({ keyPrefix: 'g' })
    bytec 5 // "g"
    swap
    concat
    dup
    cover 3
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:920
    // assert(this.games(key).exists, 'Did not found the game')
    dup
    box_len
    bury 1
    assert // Did not found the game
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:921
    // const game = this.games(key).value.copy()
    box_get
    swap
    cover 3
    assert // Box must have value
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:923
    // this.plays(sender).value.update = new UintN64(Global.latestTimestamp)
    global LatestTimestamp
    itob
    dig 2
    box_get
    assert // Box must have value
    swap
    replace2 192
    uncover 2
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:927
    // if (play.round.native < Global.round - 100) {
    pushint 16 // 16
    extract_uint64
    dup
    global Round
    pushint 100 // 100
    -
    <
    bz ClaimGame_after_if_else@2
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:928
    // this.LooseGame(key, game, play, sender)
    frame_dig 17
    frame_dig 19
    frame_dig 16
    frame_dig 14
    callsub LooseGame
    popn 3
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:929
    // this.plays(sender).value.state = new UintN64(4) // mark the state of the game 4 - timeout
    frame_dig 15
    dup
    box_get
    assert // Box must have value
    pushbytes 0x0000000000000004
    replace2 0
    dig 1
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:930
    // return this.plays(sender).value
    box_get
    assert // Box must have value
    frame_bury 0
    retsub

ClaimGame_after_if_else@2:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:936
    // const seed = BigUint(op.Block.blkSeed(play.round.native + 2))
    frame_dig 20
    pushint 2 // 2
    +
    block BlkSeed
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:938
    // const rand0_1: biguint = seed % BigUint(1_000_000)
    bytec 9 // 0x0f4240
    b%
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:941
    // const winThreshold: uint64 = (play.winProbability.native * game.winRatio.native) / 1_000_000
    frame_dig 16
    intc_3 // 8
    extract_uint64
    dup
    frame_bury 12
    frame_dig 19
    pushint 177 // 177
    extract_uint64
    *
    intc 4 // 1000000
    /
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:942
    // if (rand0_1 < BigUint(winThreshold)) {
    itob
    b<
    bz ClaimGame_else_body@21
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:946
    // (play.deposit.native * BigUint(1_000_000)) / BigUint(play.winProbability.native),
    frame_dig 16
    extract 24 32 // on error: Index access is out of bounds
    dup
    frame_bury 6
    dup
    bytec 9 // 0x0f4240
    b*
    frame_dig 12
    itob
    b/
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:945-947
    // const winAmount: biguint = BigUint(
    //   (play.deposit.native * BigUint(1_000_000)) / BigUint(play.winProbability.native),
    // )
    dup
    frame_bury 10
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:948
    // this.plays(sender).value.realTransfer = new UintN256(winAmount)
    dup
    len
    dup
    frame_bury 13
    intc_1 // 32
    <=
    assert // overflow
    intc_1 // 32
    bzero
    dup
    frame_bury 2
    dup2
    b|
    dup
    frame_bury 0
    frame_dig 15
    dup
    cover 2
    box_get
    assert // Box must have value
    swap
    replace2 88
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:949
    // const winNetAmount: biguint = winAmount - play.deposit.native
    swap
    uncover 2
    b-
    dup
    frame_bury 11
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:951
    // this.games(key).value.lastWinAmount = new UintN256(winNetAmount)
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    dup
    uncover 2
    b|
    dup
    frame_bury 1
    frame_dig 18
    dup
    cover 2
    box_get
    assert // Box must have value
    swap
    replace2 105
    dig 1
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:952
    // this.games(key).value.lastWinTime = new UintN64(Global.latestTimestamp)
    global LatestTimestamp
    itob
    dig 1
    box_get
    assert // Box must have value
    swap
    replace2 97
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:953
    // if (winNetAmount > game.biggestWinAmount.native) {
    frame_dig 19
    extract 145 32 // on error: Index access is out of bounds
    b>
    bz ClaimGame_after_if_else@5
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:954
    // this.games(key).value.biggestWinAmount = new UintN256(winNetAmount)
    frame_dig 18
    dup
    box_get
    assert // Box must have value
    frame_dig 1
    replace2 145
    dig 1
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:955
    // this.games(key).value.biggestWinTime = new UintN64(Global.latestTimestamp)
    global LatestTimestamp
    itob
    dig 1
    box_get
    assert // Box must have value
    swap
    replace2 137
    box_put

ClaimGame_after_if_else@5:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:958
    // if (game.isNativeToken.native) {
    frame_dig 19
    intc 7 // 320
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    bz ClaimGame_after_if_else@10
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:961
    // let prevDeposit: UintN256 = new UintN256(0)
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    frame_bury 3
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:962
    // if (this.allDeposits(key.assetId).exists) {
    frame_dig 17
    extract 0 8 // on error: Index access is out of bounds
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:168
    // public allDeposits = BoxMap<UintN64, UintN256>({ keyPrefix: 'd' })
    bytec 4 // "d"
    swap
    concat
    dup
    frame_bury 7
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:962
    // if (this.allDeposits(key.assetId).exists) {
    box_len
    bury 1
    bz ClaimGame_after_if_else@8
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:963
    // prevDeposit = this.allDeposits(key.assetId).value
    frame_dig 7
    box_get
    swap
    frame_bury 3
    assert // Box must have value

ClaimGame_after_if_else@8:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:965
    // assert(prevDeposit.native >= winAmount, 'There is not enough money in the sc to cover this win tx')
    frame_dig 3
    dup
    frame_dig 10
    dup
    cover 3
    b>=
    assert // There is not enough money in the sc to cover this win tx
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:966
    // this.allDeposits(key.assetId).value = new UintN256(prevDeposit.native - winNetAmount - play.deposit.native)
    frame_dig 11
    dup
    cover 3
    b-
    frame_dig 6
    b-
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    frame_dig 2
    dup
    cover 2
    b|
    frame_dig 7
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:968
    // assert(game.balance.native >= winAmount, 'There is not enough money in the sc to cover this win tx')
    frame_dig 19
    extract 0 32 // on error: Index access is out of bounds
    dup
    dig 3
    b>=
    assert // There is not enough money in the sc to cover this win tx
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:969
    // this.games(key).value.balance = new UintN256(game.balance.native - winNetAmount)
    uncover 3
    b-
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    b|
    frame_dig 18
    dup
    cover 2
    box_get
    assert // Box must have value
    swap
    replace2 0
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:971
    // this.plays(sender).value.state = new UintN64(2) // mark the state of the game 2 - win
    frame_dig 15
    dup
    box_get
    assert // Box must have value
    bytec 16 // 0x0000000000000002
    replace2 0
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:973-980
    // itxn
    //   .payment({
    //     sender: Global.currentApplicationAddress,
    //     receiver: play.owner.native,
    //     amount: new UintN64(winAmount).native,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:975
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:976
    // receiver: play.owner.native,
    frame_dig 16
    extract 160 32 // on error: Index access is out of bounds
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:977
    // amount: new UintN64(winAmount).native,
    frame_dig 13
    intc_3 // 8
    <=
    assert // overflow
    intc_3 // 8
    bzero
    uncover 3
    b|
    btoi
    itxn_field Amount
    itxn_field Receiver
    itxn_field Sender
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:973-979
    // itxn
    //   .payment({
    //     sender: Global.currentApplicationAddress,
    //     receiver: play.owner.native,
    //     amount: new UintN64(winAmount).native,
    //     fee: 0,
    //   })
    intc_2 // 1
    itxn_field TypeEnum
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:978
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:973-980
    // itxn
    //   .payment({
    //     sender: Global.currentApplicationAddress,
    //     receiver: play.owner.native,
    //     amount: new UintN64(winAmount).native,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit

ClaimGame_after_if_else@10:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:983
    // if (game.isASAToken.native) {
    frame_dig 19
    intc 5 // 321
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    bz ClaimGame_after_if_else@15
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:986
    // let prevDeposit: UintN256 = new UintN256(0)
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    frame_bury 4
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:987
    // if (this.allDeposits(key.assetId).exists) {
    frame_dig 17
    extract 0 8 // on error: Index access is out of bounds
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:168
    // public allDeposits = BoxMap<UintN64, UintN256>({ keyPrefix: 'd' })
    bytec 4 // "d"
    swap
    concat
    dup
    frame_bury 8
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:987
    // if (this.allDeposits(key.assetId).exists) {
    box_len
    bury 1
    bz ClaimGame_after_if_else@13
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:988
    // prevDeposit = this.allDeposits(key.assetId).value
    frame_dig 8
    box_get
    swap
    frame_bury 4
    assert // Box must have value

ClaimGame_after_if_else@13:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:990
    // assert(prevDeposit.native >= winAmount, 'There is not enough money in the sc to cover this win tx')
    frame_dig 4
    dup
    frame_dig 10
    dup
    cover 3
    b>=
    assert // There is not enough money in the sc to cover this win tx
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:991
    // this.allDeposits(key.assetId).value = new UintN256(prevDeposit.native - winNetAmount - play.deposit.native)
    frame_dig 11
    dup
    cover 3
    b-
    frame_dig 6
    b-
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    frame_dig 2
    dup
    cover 2
    b|
    frame_dig 8
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:993
    // assert(game.balance.native >= winAmount, 'There is not enough money in the sc to cover this win tx')
    frame_dig 19
    dup
    cover 4
    extract 0 32 // on error: Index access is out of bounds
    dup
    dig 3
    b>=
    assert // There is not enough money in the sc to cover this win tx
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:994
    // this.games(key).value.balance = new UintN256(game.balance.native - winNetAmount)
    uncover 3
    b-
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    b|
    frame_dig 18
    dup
    cover 2
    box_get
    assert // Box must have value
    swap
    replace2 0
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:996
    // this.plays(sender).value.state = new UintN64(2) // mark the state of the game 2 - win
    frame_dig 15
    dup
    box_get
    assert // Box must have value
    bytec 16 // 0x0000000000000002
    replace2 0
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:998-1006
    // itxn
    //   .assetTransfer({
    //     sender: Global.currentApplicationAddress,
    //     assetReceiver: play.owner.native,
    //     assetAmount: new UintN64(winAmount).native,
    //     xferAsset: game.assetId.native,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1000
    // sender: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1001
    // assetReceiver: play.owner.native,
    frame_dig 16
    extract 160 32 // on error: Index access is out of bounds
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1002
    // assetAmount: new UintN64(winAmount).native,
    frame_dig 13
    intc_3 // 8
    <=
    assert // overflow
    intc_3 // 8
    bzero
    uncover 3
    b|
    btoi
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1003
    // xferAsset: game.assetId.native,
    uncover 3
    intc_1 // 32
    extract_uint64
    itxn_field XferAsset
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field Sender
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:998-1005
    // itxn
    //   .assetTransfer({
    //     sender: Global.currentApplicationAddress,
    //     assetReceiver: play.owner.native,
    //     assetAmount: new UintN64(winAmount).native,
    //     xferAsset: game.assetId.native,
    //     fee: 0,
    //   })
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1004
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:998-1006
    // itxn
    //   .assetTransfer({
    //     sender: Global.currentApplicationAddress,
    //     assetReceiver: play.owner.native,
    //     assetAmount: new UintN64(winAmount).native,
    //     xferAsset: game.assetId.native,
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit

ClaimGame_after_if_else@15:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1008
    // if (game.isArc200Token.native) {
    frame_dig 19
    intc 6 // 322
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    bz ClaimGame_after_if_else@22
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1009
    // let prevDeposit: UintN256 = new UintN256(0)
    bytec_1 // 0x0000000000000000000000000000000000000000000000000000000000000000
    frame_bury 5
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1010
    // if (this.allDeposits(key.assetId).exists) {
    frame_dig 17
    extract 0 8 // on error: Index access is out of bounds
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:168
    // public allDeposits = BoxMap<UintN64, UintN256>({ keyPrefix: 'd' })
    bytec 4 // "d"
    swap
    concat
    dup
    frame_bury 9
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1010
    // if (this.allDeposits(key.assetId).exists) {
    box_len
    bury 1
    bz ClaimGame_after_if_else@18
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1011
    // prevDeposit = this.allDeposits(key.assetId).value
    frame_dig 9
    box_get
    swap
    frame_bury 5
    assert // Box must have value

ClaimGame_after_if_else@18:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1013
    // assert(prevDeposit.native >= winAmount, 'There is not enough money in the sc to cover this win tx')
    frame_dig 5
    dup
    frame_dig 10
    dup
    cover 3
    b>=
    assert // There is not enough money in the sc to cover this win tx
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1014
    // this.allDeposits(key.assetId).value = new UintN256(prevDeposit.native - winNetAmount - play.deposit.native)
    frame_dig 11
    dup
    cover 3
    b-
    frame_dig 6
    b-
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    frame_dig 2
    dup
    cover 2
    b|
    frame_dig 9
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1016
    // assert(game.balance.native >= winAmount, 'There is not enough money in the sc to cover this win tx')
    frame_dig 19
    dup
    cover 4
    extract 0 32 // on error: Index access is out of bounds
    dup
    uncover 3
    b>=
    assert // There is not enough money in the sc to cover this win tx
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1017
    // this.games(key).value.balance = new UintN256(game.balance.native - winNetAmount)
    uncover 2
    b-
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    b|
    frame_dig 18
    dup
    cover 2
    box_get
    assert // Box must have value
    swap
    replace2 0
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1019
    // this.plays(sender).value.state = new UintN64(2) // mark the state of the game 2 - win
    frame_dig 15
    dup
    box_get
    assert // Box must have value
    bytec 16 // 0x0000000000000002
    replace2 0
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1022-1028
    // itxn
    //   .applicationCall({
    //     appId: game.assetId.native,
    //     appArgs: [methodSelector('arc200_transfer(address,uint256)bool'), play.owner, new UintN256(winAmount)],
    //     fee: 0,
    //   })
    //   .submit()
    itxn_begin
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1024
    // appId: game.assetId.native,
    intc_1 // 32
    extract_uint64
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1025
    // appArgs: [methodSelector('arc200_transfer(address,uint256)bool'), play.owner, new UintN256(winAmount)],
    frame_dig 16
    extract 160 32 // on error: Index access is out of bounds
    bytec 12 // method "arc200_transfer(address,uint256)bool"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    frame_dig 0
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1022-1027
    // itxn
    //   .applicationCall({
    //     appId: game.assetId.native,
    //     appArgs: [methodSelector('arc200_transfer(address,uint256)bool'), play.owner, new UintN256(winAmount)],
    //     fee: 0,
    //   })
    pushint 6 // 6
    itxn_field TypeEnum
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1026
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1022-1028
    // itxn
    //   .applicationCall({
    //     appId: game.assetId.native,
    //     appArgs: [methodSelector('arc200_transfer(address,uint256)bool'), play.owner, new UintN256(winAmount)],
    //     fee: 0,
    //   })
    //   .submit()
    itxn_submit

ClaimGame_after_if_else@22:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1034
    // return this.plays(sender).value
    frame_dig 15
    box_get
    assert // Box must have value
    frame_bury 0
    retsub

ClaimGame_else_body@21:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1032
    // this.LooseGame(key, game, play, sender)
    frame_dig 17
    frame_dig 19
    frame_dig 16
    frame_dig 14
    callsub LooseGame
    popn 3
    b ClaimGame_after_if_else@22


// smart_contracts/avm_satoshi_dice/contract.algo.ts::AvmSatoshiDice.LooseGame(key: bytes, game: bytes, play: bytes, sender: bytes) -> bytes, bytes, bytes:
LooseGame:
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1037
    // private LooseGame(key: AddressAssetStruct, game: GameStruct, play: PlayStruct, sender: Address) {
    proto 4 3
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:166
    // public games = BoxMap<AddressAssetStruct, GameStruct>({ keyPrefix: 'g' })
    bytec 5 // "g"
    frame_dig -4
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1042
    // const gameProfitRatio: uint64 = 1_000_000 - this.games(key).value.winRatio.native
    dup
    box_get
    assert // Box must have value
    pushint 177 // 177
    extract_uint64
    intc 4 // 1000000
    swap
    -
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1043
    // const feeRatio: uint64 = gameProfitRatio / 5
    pushint 5 // 5
    /
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1044
    // const fee: biguint = (play.deposit.native * BigUint(feeRatio)) / BigUint(1_000_000)
    frame_dig -2
    extract 24 32 // on error: Index access is out of bounds
    swap
    itob
    dig 1
    b*
    bytec 9 // 0x0f4240
    b/
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1046
    // this.allDeposits(key.assetId).value = new UintN256(this.allDeposits(key.assetId).value.native - fee)
    frame_dig -4
    extract 0 8 // on error: Index access is out of bounds
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:168
    // public allDeposits = BoxMap<UintN64, UintN256>({ keyPrefix: 'd' })
    bytec 4 // "d"
    swap
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1046
    // this.allDeposits(key.assetId).value = new UintN256(this.allDeposits(key.assetId).value.native - fee)
    dup
    box_get
    assert // Box must have value
    dig 2
    b-
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    intc_1 // 32
    bzero
    swap
    dig 1
    b|
    uncover 2
    swap
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1047
    // this.games(key).value.balance = new UintN256(game.balance.native + play.deposit.native - fee)
    frame_dig -3
    extract 0 32 // on error: Index access is out of bounds
    uncover 3
    b+
    uncover 2
    b-
    dup
    len
    intc_1 // 32
    <=
    assert // overflow
    b|
    dig 1
    box_get
    assert // Box must have value
    swap
    replace2 0
    box_put
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:167
    // public plays = BoxMap<Address, PlayStruct>({ keyPrefix: 'p' })
    bytec 7 // "p"
    frame_dig -1
    concat
    // smart_contracts/avm_satoshi_dice/contract.algo.ts:1048
    // this.plays(sender).value.state = new UintN64(3) // mark the state of the game 3 - loose
    dup
    box_get
    assert // Box must have value
    pushbytes 0x0000000000000003
    replace2 0
    box_put
    frame_dig -4
    frame_dig -3
    frame_dig -2
    retsub
